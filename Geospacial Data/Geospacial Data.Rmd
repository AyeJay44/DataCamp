---
title: "Working With Geospacial Data"
author: "Ken Harmon"
date: "`r format(Sys.time(), '%Y %B %d')`"
output:
  html_document:  
    keep_md: true
    code_folding: hide
    fig_height: 6
    fig_width: 12
    fig_align: 'center'
editor_options: 
  chunk_output_type: console
---

# {.tabset .tabset-fade}

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r load_libraries, include=FALSE}
# Use this R-Chunk to load all your libraries!
pacman::p_load(tidyverse, ggmap)
theme_set(theme_bw())
register_google(key = "AIzaSyAfnLNZjvYdMx-cyga_qA1oJ6P36dRGalA") 

```

## Google Mapping API

https://cloud.google.com/maps-platform/

```{r swd, eval=FALSE, echo=FALSE}
# this is set to not run during the knit process
# this sets the working directory to the file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

## Basic Mapping

Grabbing a background map
There are two steps to adding a map to a ggplot2 plot with ggmap:

Download a map using get_map()
Display the map using ggmap()
As an example, let's grab a map for New York City:

library(ggmap)

nyc <- c(lon = -74.0059, lat = 40.7128)
nyc_map <- get_map(location = nyc, zoom = 10)
get_map() has a number of arguments that control what kind of map to get, but for now you'll mostly stick with the defaults. The most important argument is the first, location, where you can provide a longitude and latitude pair of coordinates where you want the map centered. (We found these for NYC from a quick google search of "coordinates nyc".) The next argument, zoom, takes an integer between 3 and 21 and controls how far the mapped is zoomed in. In this exercise, you'll set a third argument, scale, equal to 1. This controls the resolution of the downloaded maps and you'll set it lower (the default is 2) to reduce how long it takes for the downloads.

Displaying the map is then as simple as calling ggmap() with your downloaded map as the only argument: ggmap(nyc_map)

Your turn! We are going to be looking at house sales in Corvallis, but you probably have no idea where that is! Let's find out.

Instructions
100 XP
We've created for you a pair of coordinates called corvallis. Get a map centered on Corvallis at the following zoom levels and use ggmap() to plot each. Don't forget to set scale = 1 to reduce download times.

zoom = 5 (Corvallis is in the State of Oregon on the West Coast of the USA.)
zoom = 13 (The Willamette River runs through town, and Corvallis is the home of Oregon State University.)

```{r gbm}

corvallis <- c(lon = -123.2620, lat = 44.5646)

# Get map at zoom level 5: map_5
map_5 <- get_map(corvallis, zoom = 5, scale = 1)

# Plot map at zoom level 5
ggmap(map_5)

# Get map at zoom level 13: corvallis_map
corvallis_map <- get_map(corvallis, zoom = 13, scale = 1)

# Plot map at zoom level 13
ggmap(corvallis_map)
```

Putting it all together
You now have a nice map of Corvallis, but how do you put the locations of the house sales on top?

Similar to ggplot(), you can add layers of data to a ggmap() call (e.g. + geom_point()). It's important to note, however, that ggmap() sets the map as the default dataset and also sets the default aesthetic mappings.

This means that if you want to add a layer from something other than the map (e.g. sales), you need to explicitly specify both the mapping and data arguments to the geom.

What does this look like? You've seen how you might make a basic plot of the sales:

ggplot(sales, aes(lon, lat)) + 
  geom_point()
An equivalent way to specify the same plot is:

ggplot() + 
  geom_point(aes(lon, lat), data = sales)
Here, we've specified the data and mapping in the call to geom_point() rather than ggplot(). The benefit of specifying the plot this way is you can swap out ggplot() for a call to ggmap() and get a map in the background of the plot.

Instructions
100 XP
The ggmap package has been loaded for you and corvallis_map from the previous exercise is available in your workspace.

First, take a look at the head() of the sales data. Can you see the columns specifying the location of the house?
Swap out the call to ggplot() with a call to ggmap() with corvallis_map.

```{r piat}
sales <- read.csv("sales.csv") %>% as_tibble()

# Look at head() of sales
head(sales)

# Swap out call to ggplot() with call to ggmap()
ggmap(corvallis_map) +
  geom_point(aes(lon, lat), data = sales)
```

Insight through aesthetics
Adding a map to your plot of sales explains some of the structure in the data: there are no house sales East of the Willamette River or on the Oregon State University campus. This structure is really just a consequence of where houses are in Corvallis; you can't have a house sale where there are no houses!

The value of displaying data spatially really comes when you add other variables to the display through the properties of your geometric objects, like color or size. You already know how to do this with ggplot2 plots: add additional mappings to the aesthetics of the geom.

Let's see what else you can learn about these houses in Corvallis.

NOTE: Many exercises in this course will require you to create more than one plot. You can toggle between plots with the arrows at the bottom of the 'Plots' window and zoom in on a plot by clicking the arrows on the tab at the top of the 'Plots' window.

Instructions 3/3
34 XP
Map the color of the points to year_built. How has Corvallis developed as a town?

Map the size of the points to bedrooms. Are there areas of houses with fewer or more bedrooms?

Map the color of the points to price per squarefoot (i.e. price / finished_squarefeet). Are there areas with better "value" than others? What makes this plot unsuccessful?

```{r itta}
# Map color to year_built
ggmap(corvallis_map) +
    geom_point(aes(lon, lat, color = year_built), data = sales)
# Map size to bedrooms
ggmap(corvallis_map) +
    geom_point(aes(lon, lat, size = bedrooms), data = sales)
# Map color to price / finished_squarefeet
ggmap(corvallis_map) +
    geom_point(aes(lon, lat, color = price / finished_squarefeet), data = sales)
```

Different maps
The default Google map downloaded by get_map() is useful when you need major roads, basic terrain, and places of interest, but visually it can be a little busy. You want your map to add to your data, not distract from it, so it can be useful to have other "quieter" options.

Sometimes you aren't really interested in the roads and places, but more what's on the ground (e.g. grass, trees, desert, or snow), in which case switching to a satellite view might be more useful. You can get Google satellite images by changing the maptype argument to "satellite".

You can grab Stamen Maps by using source = "stamen" in get_map(), along with specifying a maptype argument. You can see all possible values for the maptype argument by looking at ?get_map, but they correspond closely to the "flavors" described on the Stamen Maps site. I like the "toner" variations, as they are greyscale and a bit simpler than the Google map.

Let's try some other maps for your plot of house sales.

Instructions 2/2
50 XP
Edit your original call to get_map() to get a "satellite" image from Google by adding a maptype argument.
Display a plot of house sales coloured by year_built using the satellite map.
Edit your original call to get_map() to get a toner map from Stamen by adding a source argument and a maptype argument.
Display a plot of house sales coloured by year_built using the toner map.

```{r dm}
corvallis <- c(lon = -123.2620, lat = 44.5646)

# Add a maptype argument to get a satellite map
corvallis_map_sat <- get_map(corvallis, zoom = 13, maptype = "satellite")
 
 
# Edit to display satellite map
ggmap(corvallis_map_sat) +
  geom_point(aes(lon, lat, color = year_built), data = sales)

corvallis <- c(lon = -123.2620, lat = 44.5646)
 
# Add source and maptype to get toner map from Stamen Maps
corvallis_map_bw <- get_map(corvallis, zoom = 13, source = "stamen", maptype = "toner")

# Edit to display toner map
ggmap(corvallis_map_bw) +
  geom_point(aes(lon, lat, color = year_built), data = sales)
```

Leveraging ggplot2's strengths
You've seen you can add layers to a ggmap() plot by adding geom_***() layers and specifying the data and mapping explicitly, but this approach has two big downsides: further layers also need to specify the data and mappings, and facetting won't work at all.

Luckily ggmap() provides a way around these downsides: the base_layer argument. You can pass base_layer a normal ggplot() call that specifies the default data and mappings for all layers.

For example, the initial plot:

ggmap(corvallis_map) +
  geom_point(data = sales, aes(lon, lat))
could have instead been:

ggmap(corvallis_map, 
    base_layer = ggplot(sales, aes(lon, lat))) +
  geom_point()
By moving aes(x, y) and data from the initial geom_point() function to the ggplot() call within the ggmap() call, you can add facets, or extra layers, the usual ggplot2 way.

Let's try it out.

Instructions 1/2
50 XP
1
2
Rewrite the first plot to use the base_layer argument of ggmap().

Add a base_layer argument to the ggmap() call.
This should call ggplot().
Move the data and x and y mappings out of geom_point(). Leave the color argument inside the aes() function within your geom_point() call.

Rewrite the plot to use the base_layer argument of ggmap(). Set the color argument inside the aes() function to class.
Add a facet_wrap() to facet by class. This function takes a formula.

```{r lgs}
# Use base_layer argument to ggmap() to specify data and x, y mappings

  ggmap(corvallis_map_bw, 
    base_layer = ggplot(sales, aes(lon, lat))) +
  geom_point(aes(color = year_built))

# Use base_layer argument to ggmap() and add facet_wrap()
  ggmap(corvallis_map_bw, 
    base_layer = ggplot(sales, aes(lon, lat))) +
  geom_point(aes(color = class)) +
  facet_wrap(vars(class))
```

A quick alternative
ggmap also provides a quick alternative to ggmap(). Like qplot() in ggplot2, qmplot() is less flexible than a full specification, but often involves significantly less typing. qmplot() replaces both steps -- downloading the map and displaying the map -- and its syntax is a blend between qplot(), get_map(), and ggmap().

Let's take a look at the qmplot() version of the faceted plot from the previous exercise:

qmplot(lon, lat, data = sales, 
       geom = "point", color = class) +
  facet_wrap(~ class)
Notice we didn't specify a map, since qmplot() will grab one on its own. Otherwise the qmplot() call looks a lot like the corresponding qplot() call: use points to display the sales data, mapping lon to the x-axis, lat to the y-axis, and class to color. qmplot() also sets the default dataset and mapping (without the need for base_layer) so you can add facets without any extra work.

Instructions
100 XP
Using the example as a guide, use qmplot() to create a plot of the house sales where color is mapped to bedrooms, faceted by month.

```{r aqa}
# Plot house sales using qmplot()
qmplot(lon, lat, data = sales, 
       geom = "point", color = bedrooms) +
  facet_wrap(~ month)
```

Drawing polygons
A choropleth map describes a map where polygons are colored according to some variable. In the ward_sales data frame, you have information on the house sales summarised to the ward level. Your goal is to create a map where each ward is colored by one of your summaries: the number of sales or the average sales price.

In the data frame, each row describes one point on the boundary of a ward. The lon and lat variables describe its location and ward describes which ward it belongs to, but what are group and order?

Remember the two tricky things about polygons? An area may be described by more than one polygon and order matters. group is an identifier for a single polygon, but a ward may be composed of more than one polygon, so you would see more than one value of group for such a ward. order describes the order in which the points should be drawn to create the correct shapes.

In ggplot2, polygons are drawn with geom_polygon(). Each row of your data is one point on the boundary and points are joined up in the order in which they appear in the data frame. You specify which variables describe position using the x and y aesthetics and which points belong to a single polygon using the group aesthetic.

This is a little tricky, so before you make your desired plot, let's explore this a little more.

Instructions 4/4
25 XP
The ward_sales data frame is loaded in your workspace. You may want to take a look with head(ward_sales).

Add a geom_point() layer with the color aesthetic mapped to ward. How many wards are in Corvallis?
Add a geom_point() layer with the color aesthetic mapped to group. Can you see some wards that are described by more than one polygon?
Add a geom_path() layer with the group aesthetic mapped to group. See how points in the same group are joined.
Finally, add a geom_polygon() layer with the fill aesthetic mapped to ward and the group aesthetic mapped to group.

```{r dp}
ward_sales <- read.csv("ward_sales.csv")

# Add a point layer with color mapped to ward
ggplot(ward_sales, aes(lon, lat)) +
geom_point(aes(color = ward))

# Add a point layer with color mapped to group

ggplot(ward_sales, aes(lon, lat)) +
geom_point(aes(color = group))

# Add a path layer with group mapped to group
ggplot(ward_sales, aes(lon, lat)) +
geom_path(aes(group = group))

# Add a polygon layer with fill mapped to ward, and group to group
ggplot(ward_sales, aes(lon, lat)) +
geom_polygon(aes(fill = as.factor(ward), group = group))
```

