---
title: "Building Web Applications in R with Shiny: Case Studies"
author: "Ken Harmon"
date: "`r format(Sys.time(), '%Y %B %d')`"
output:
  pdf_document: default
  html_document:
    code_folding: hide
    fig_align: center
    fig_height: 6
    fig_width: 12
    keep_md: yes
editor_options:
  chunk_output_type: console
---

# {.tabset .tabset-fade}

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r load_libraries, include=FALSE}
# Use this R-Chunk to load all your libraries!
pacman::p_load(tidyverse, shiny, gapminder, colourpicker, plotly)
theme_set(theme_bw())


```

https://www.datacamp.com/courses/building-web-applications-in-r-with-shiny-case-studies

## Google Mapping API

https://cloud.google.com/maps-platform/

```{r swd, eval=FALSE, echo=FALSE}
# this is set to not run during the knit process
# this sets the working directory to the file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

## Shiny Review

Simple text
Every Shiny app has a UI (User Interface) portion and a server portion. The UI is where the visual elements are placed—it controls the layout and appearance of your app. The server is where the logic of the app is implemented—for example, where calculations are performed and plots are generated.

An empty UI is created using the fluidPage() function. Adding text to a Shiny app is done by adding text inside fluidPage() as an argument. In fact, the entire UI is built by supplying the fluidPage() function with as many arguments as you want.

Instructions
100 XP
Create a Shiny app that displays the text "Shiny is fun" by following these specific instructions:

Load the shiny package.
Create the UI for the Shiny app using the fluidPage() function.
Add the text "Shiny is fun" to the UI.

```{r st}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # Add the text "Shiny is fun"
  "Shiny is fun"
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Formatted text
Shiny has many functions that can transform plain text into formatted text. Simply place text inside the h1() function to create a primary header (e.g. a title), h2() for a secondary header, strong() to make text bold, em() to make text italicized, or any of the other formatting functions.

You can also intermingle plain text and formatted text as much as you'd like—just remember to separate all the elements with commas!

Instructions
100 XP
Place the following text inside the Shiny app:

The word "DataCamp" as a primary header.
The words "Shiny use cases course" as a secondary header.
The word "Shiny" in italics.
The words "is fun" as bold text.
After completing the instructions, your Shiny app should render the following text:

DataCamp
Shiny use cases course
Shiny is fun

```{r ft}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # "DataCamp" as a primary header
  h1("DataCamp"),
  # "Shiny use cases course" as a secondary header
  h2("Shiny use cases course"),
  # "Shiny" in italics
  em("Shiny"),
  # "is fun" as bold text
  strong("is fun")
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Adding structure to your app
Layouts in Shiny are used to give your app some structure by placing elements in certain desired positions.

A sidebar layout, created with the sidebarLayout() function, provides a basic two-column structure with a smaller sidebar on the left and a larger main panel on the right.

The sidebar layout function takes two arguments: sidebarPanel() and mainPanel(). Each of these panels can contain any arbitrary mix of text/HTML elements, in a similar fashion to how you can mix these elements inside a fluidPage().

Instructions
100 XP
Your task is to add a sidebar layout to the existing app, such that the inputs will be on the left side and the outputs will be in the main panel. Specifically, you need to:

Define the UI for the Shiny application.
Add a sidebar layout to the page.
Add a sidebar panel to the layout, and place the inputs and text in it.
Add a main panel to the layout, and place the plot and table in it.

```{r astya}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # Add a sidebar layout to the application
  sidebarLayout(
    # Add a sidebar panel around the text and inputs
    sidebarPanel(
      h4("Plot parameters"),
      textInput("title", "Plot title", "Car speed vs distance to stop"),
      numericInput("num", "Number of cars to show", 30, 1, nrow(cars)),
      sliderInput("size", "Point size", 1, 5, 2, 0.5)
    ),
    # Add a main panel around the plot and table
    mainPanel(
      plotOutput("plot"),
      tableOutput("table")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    plot(cars[1:input$num, ], main = input$title, cex = input$size)
  })
  output$table <- renderTable({
    cars[1:input$num, ]
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Adding inputs
Inputs are Shiny's way of allowing users to interact with an app. For example, textInput() is used to let the user enter text and numericInput() lets the user select a number. In the next chapter we will see many other types of inputs.

To add an input to your app, simply add the input function inside fluidPage(). Recall from the video that all input functions have the same first two arguments: inputId and label.

Instructions
100 XP
Define the UI for the Shiny application.
Create a numeric input with ID "age" and a descriptive label of "How old are you?".
Create a text input with ID "name" and a label of "What is your name?".

```{r ai}
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # Create a numeric input with ID "age" and label of
  # "How old are you?"
  numericInput("age", "How old are you?", value = 20),
  
  # Create a text input with ID "name" and label of 
  # "What is your name?"
  textInput("name", "What is your name?")
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Adding placeholders for outputs
Outputs are any object that should be displayed to the user and is generated in R, such as a plot or a table.

To add an output to a Shiny app, the first thing you need to do is add a placeholder for the output that tells Shiny where to place the output.

There are several output placeholder functions provided by Shiny, one for each type of output. For example, plotOutput() is for displaying plots, tableOutput() is for outputting tables, and textOutput() is for dynamic text.

Instructions
100 XP
Create a text input with an ID of "name" in the sidebar panel.
Add three output placeholders to the main panel:
A text output with ID "greeting" (line 14).
A plot output with ID "cars_plot" (line 16).
A table output with ID "iris_table" (line 18).

```{r apfo}
library(shiny)

# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      # Create a text input with an ID of "name"
      textInput("name", "What is your name?", "Dean"),
      numericInput("num", "Number of flowers to show data for",
                   10, 1, nrow(iris))
    ),
    mainPanel(
      # Add a placeholder for a text output with ID "greeting"
      textOutput(outputId = "greeting"),
      # Add a placeholder for a plot with ID "cars_plot"
      plotOutput("cars_plot"),
      # Add a placeholder for a table with ID "iris_table"
      tableOutput("iris_table")
    )
  )
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Constructing output objects
There are three rules to build an output in Shiny:

Build the object with the appropriate render*() function.

Save the result of the render function into the output list, which is a parameter of the server function. Specifically, save it into output$<outputId> in order to replace the output placeholder in the UI that has ID outputId.

If the output relies on any user-modified input values, you can access any of the inputs using the input parameter of the server function. Specifically, input$<inputId> will always return the current value of the input field that has ID inputId.

Instructions
100 XP
You are given a Shiny app with a fully functional UI portion. Your task is to construct all the outputs. Specifically:

Create a plot of the cars dataset in the plot output placeholder with ID "cars_plot" (line 23).
In the "greeting" text output, render a text greeting in the form of "Hello NAME", where NAME is the value of the name input (line 28).
In the "iris_table" output, show a table of the first n rows of the iris dataset, where n is the value of the numeric input (line 33).

```{r coo}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("name", "What is your name?", "Dean"),
      numericInput("num", "Number of rows to show in the table",
                   10, 1, nrow(iris))
    ),
    mainPanel(
      textOutput("greeting"),
      plotOutput("cars_plot"),
      tableOutput("iris_table")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  # Create a plot of the "cars" dataset 
  output$cars_plot <- renderPlot({
    plot(cars)
  })
  
  # Render a text greeting as "Hello <name>"
  output$greeting <- renderText({
    paste("Hello", input$name)
  })
  
  # Show a table of the first n rows of the "iris" data
  output$iris_table <- renderTable({
    data <- iris[1:input$num, ]
    data
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Reactive contexts
Reactive values are special constructs in Shiny; they are not seen anywhere else in R programming. As such, they cannot be used in just any R code, reactive values can only be accessed within a reactive context.

This is the reason why any variable that depends on a reactive value must be created using the reactive() function, otherwise you will get an error. The shiny server itself is not a reactive context, but the reactive() function, the observe() function, and all render*() functions are.

Instructions
100 XP
You are provided with a Shiny app containing two numeric inputs, num1 and num2, and a text output. Your task is to:

In a reactive variable called my_sum, calculate the sum of the two numeric inputs (line 10).
In a reactive variable called my_average, calculate the average of the two inputs (line 14).
In the text output, display the calculated average using the reactive variables (line 23).

```{r rc}
ui <- fluidPage(
  numericInput("num1", "Number 1", 5),
  numericInput("num2", "Number 2", 10),
  textOutput("result")
)

server <- function(input, output) {
  # Calculate the sum of the inputs
  my_sum <- reactive({
    input$num1 + input$num2
  })

  # Calculate the average of the inputs
  my_average <- reactive({
    my_sum() / 2
  })
  
  output$result <- renderText({
    paste(
      # Print the calculated sum
      "The sum is", my_sum(),
      # Print the calculated average
      "and the average is", my_average()
    )
  })
}

shinyApp(ui, server)
```

## Perfect Plot

More exploration of the Gapminder data
To use the gapminder data in a Shiny app, you will often have to filter the dataset in order to retain only a subset of the rows. You can use the subset() function for that.

Instructions
100 XP
You are given a Shiny app that contains an empty text output. Your task is to:

Load the gapminder package.
Determine the population of France in year 1972 using the subset() function, and display that number in the text output (line 14).

```{r megd}
# Load the gapminder package
library(gapminder)

# Define UI for the application
ui <- fluidPage(
  "The population of France in 1972 was", 
  textOutput("answer")
)

# Define the server function
server <- function(input, output) {
  output$answer <- renderText({
    # Determine the population of France in year 1972
    subset(gapminder, country == "France" & year == 1972)$pop
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Add a plot title: text input
In Shiny, as soon as the user changes the value of any input, Shiny makes the current value of that input immediately available to you in the server through the input argument of the server function. You can retrieve the value of any input using input$<inputId>.

In order to assign a default initial value to a text input, the value argument is used.

Instructions
100 XP
The given Shiny app plots the GDP per capita vs life expectancy of countries in the gapminder dataset. Your task is to add a text input that lets users change the title of the plot. Specifically:

Add a text input to the UI with ID "title", a label of "Title", and a default value of "GDP vs life exp".
In the server code, make the title of the plot always reflect the current value of the title input by placing the title inside the ggtitle() function (line 24).

```{r aptti}
# Load the ggplot2 package for plotting
library(ggplot2)

# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      # Add a title text input
      textInput("title", "Title", "GDP vs life exp")
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10() +
      # Use the input value as the plot's title
      ggtitle(input$title)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Change the point size: numeric input
Numeric inputs have a few more arguments that text inputs do not have, such as min and max, which define the minimum and maximum numbers that can be chosen.

Note that when the value of an input is accessed in the server code, Shiny is smart enough to know what type of input was used, and therefore what type of object it should return. This means that if you have a numeric input with ID "foo", then input$foo will return a numeric value.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to add a numeric input that the user can use to change the size of the points on the plot. Specifically:

Add a numeric input to the UI with ID "size", a label of "Point size", a default value of 1, and a minimum value of 1.
Add code to the server so that the numeric input will determine the point size in the plot (line 20).

```{r cpsni}
# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      # Add a size numeric input
      numericInput("size","Point size",1,min = 1)
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      # Use the size input as the plot point size
      geom_point(size = input$size) +
      scale_x_log10() +
      ggtitle(input$title)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Fit a smooth curve: checkbox input
Unlike text and numeric inputs, checkbox inputs are limited to only two possible values: TRUE or FALSE. When the user checks a checkbox input, the input has a value of TRUE, and if the box is unchecked then it returns FALSE.

Note that the value parameter of the checkboxInput() function, which defines the initial value, can only be set to either TRUE or FALSE.

The code for the Shiny app from the last exercise is provided with some modification. The ggplot plot object inside renderPlot() is now assigned to a variable p.

Instructions
100 XP
Your task is to add a checkbox input that, when checked, will add a line of best fit to the plot. Specifically:

Add a checkbox input to the UI with ID "fit", a label of "Add line of best fit", and an initial state of being unchecked.
Add code to the server so that when the input is checked, a line of best fit is added to the plot. The code for adding a line of best fit is provided (line 26).

```{r fscci}
# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      # Add a checkbox for line of best fit
      checkboxInput("fit","Add line of best fit",value = FALSE)
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    p <- ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size) +
      scale_x_log10() +
      ggtitle(input$title)
    
    # When the "fit" checkbox is checked, add a line
    # of best fit
    if (input$fit == TRUE) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Add colours to your plot: radio buttons
Radio buttons are used when you want to present the user with several options and ask them to choose one. They have a choices parameter that defines the different options the user can choose from, and a selected argument that defines which choice is selected initially. Note that there is no value parameter, though you can think of selected as having a similar role.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to add radio buttons that give the user a choice of color to use for the plot. Specifically:

Add radio buttons to the UI with ID "color", a label of "Point color", and four choices: "blue", "red", "green", "black".
Add code to the server such that the points in the plot will have the color that is selected in the radio buttons (line 22).

```{r actyprb}
# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      # Add radio buttons for colour
      radioButtons("color", "Point color", c("blue", "red", "green", "black"))
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    p <- ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      # Use the value of the color input as the point colour
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Add a continent selector: select input
When there are many options to let the user choose from, radio buttons can take up a lot of space and may not be ideal. Select inputs—also called 'dropdown lists'—can also be used to ask the user to choose an option from a list of choices, but in a more compact way. With a select input, all the options appear in a scrollable list, so it can be used even if you have many choices.

Similar to radio buttons, select inputs also have choices and selected parameters. Additionally, select inputs have a multiple argument, which, when set to TRUE, allows the user to select more than one value.

The code for the Shiny app from the last exercise is provided with slight modifications.

Instructions
100 XP
Add a selectInput() to the UI with ID "continents" and a label of "Continents", with the default continent set to "Europe".
The choices in the list should be all the different continents that exist in the gapminder dataset.
Allow the user to select multiple continents simultaneously.
Add code to the server such that only data for the selected continent is shown, by subsetting the gapminder dataset (line 23).

```{r acssi}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      radioButtons("color", "Point color",
                   choices = c("blue", "red", "green", "black")),
      # Add a continent dropdown selector
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe")
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    # Subset the gapminder dataset by the chosen continents
    data <- subset(gapminder,
                   continent %in% input$continents)

    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Add a year filter: numeric slider input
Slider inputs can be used for similar purposes to numeric inputs, as they both provide the user with a way to select a number.

If the initial provided value (the value argument) of the slider is a single number, then the slider will be used to select single numbers. However, if the initial value is a vector of two numbers, then the slider will be used to select two numbers instead of just a single value.

We have already seen that different inputs may have different arguments. It can be difficult to remember the exact arguments each input uses. The only way to find out what arguments you can use with a specific input function is by looking at its documentation or help file.

Instructions
100 XP
Add a sliderInput() to the UI with ID "years" and a label of "Years" (line 14).
Set the minimum value to the earliest year in the dataset, and the maximum value to the latest year in the dataset.
By default, the endpoints of the slider should be set to 1977 and 2002, so that only data between these two years (inclusive) is shown.
Add code to the server such that the years that are chosen in the input are used to subset the gapminder data, and only records within these years will show up (line 28).

```{r ayfasi}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      radioButtons("color", "Point color",
                   choices = c("blue", "red", "green", "black")),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      # Add a slider selector for years to filter
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002), step = 1)
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    # Subset the gapminder data by the chosen years
    data <- subset(gapminder,
                   continent %in% input$continents &
                   year >= input$years[1] & year <= input$years[2])
    
    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Add colours to your plot: color input
The colourpicker package provides a color input, available through the colourInput() function. Even though color inputs are not part of the shiny package, they behave in the same way as any other input.

A color input can have many different arguments you can explore, but we will only use the basic arguments: inputId, label, and value. The value argument accepts a color to use as the initial value. Colours can be specified in several different formats, but the easiest one is to simply use English color names such as "red" or "yellow".

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to replace the radio buttons that are used to select a color with a color input. Specifically:

Load the colourpicker package.
Find the UI function that creates the radio buttons that are used for selecting a colour, and replace it with a color input (line 12).
The color input should have ID "color", a label of "Point color", and a default color of "blue".

```{r actypci}
# Load the colourpicker package
library(colourpicker)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),

      # Replace the radio buttons with a color input
      colourInput("color", "Point color", value = "blue", showColour = c("both", "text", "background")),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002))
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    data <- subset(gapminder,
                   continent %in% input$continents &
                   year >= input$years[1] & year <= input$years[2])
    
    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Making your plot larger
Just as input functions can have different arguments depending on the type of input, so can output placeholder functions have different arguments to modify their appearance or behaviour.

For example, when displaying a plot in a Shiny app using plotOutput(), the height of the plot by default will be 400 pixels. The plotOutput() function has some parameters that can be used to modify the height or width of a plot.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to make the plot larger. Specifically:

600 pixels tall and 600 pixels wide. You can consult the plotOutput() documentation to find out what parameters to use (line 18).

```{r mypl}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      colourInput("color", "Point color", value = "blue"),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002))
    ),
    mainPanel(
      # Make the plot 600 pixels wide and 600 pixels tall
      plotOutput("plot", width = "600px", height = "600px")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    data <- subset(gapminder,
                   continent %in% input$continents &
                     year >= input$years[1] & year <= input$years[2])
    
    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Make your plot interactive
plotly is a popular package for creating interactive plots in Shiny. There are several other packages for interactive visualizations, but we will use plotly largely because of its function ggplotly(), which converts a ggplot2 plot into an interactive one.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to replace the ggplot2 plot with a plotly plot. Specifically:

Load the plotly package.
Replace the plot output function with plotlyOutput (line 20).
Replace the plot render function with renderPlotly (line 29).
Convert the existing ggplot2 plot to a plotly plot (line 31).

```{r mypi}
# Load the plotly package
library(plotly)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      colourInput("color", "Point color", value = "blue"),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002))
    ),
    mainPanel(
      # Replace the `plotOutput()` with the plotly version
      plotlyOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  # Replace the `renderPlot()` with the plotly version
  output$plot <- renderPlotly({
    # Convert the existing ggplot2 to a plotly plot
    ggplotly({
      data <- subset(gapminder,
                     continent %in% input$continents &
                       year >= input$years[1] & year <= input$years[2])
      
      p <- ggplot(data, aes(gdpPercap, lifeExp)) +
        geom_point(size = input$size, col = input$color) +
        scale_x_log10() +
        ggtitle(input$title)
      
      if (input$fit) {
        p <- p + geom_smooth(method = "lm")
      }
      p
    })
  })
}

shinyApp(ui = ui, server = server)
```

