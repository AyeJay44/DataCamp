---
title: "Building Web Applications in R with Shiny: Case Studies"
author: "Ken Harmon"
date: "`r format(Sys.time(), '%Y %B %d')`"
output:
  pdf_document: default
  html_document:
    code_folding: hide
    fig_align: center
    fig_height: 6
    fig_width: 12
    keep_md: yes
editor_options:
  chunk_output_type: console
---

# {.tabset .tabset-fade}

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r load_libraries, include=FALSE}
# Use this R-Chunk to load all your libraries!
pacman::p_load(tidyverse, shiny, gapminder, colourpicker, plotly, DT)
theme_set(theme_bw())


```

https://www.datacamp.com/courses/building-web-applications-in-r-with-shiny-case-studies

## Google Mapping API

https://cloud.google.com/maps-platform/

```{r swd, eval=FALSE, echo=FALSE}
# this is set to not run during the knit process
# this sets the working directory to the file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

## Shiny Review

Simple text
Every Shiny app has a UI (User Interface) portion and a server portion. The UI is where the visual elements are placed—it controls the layout and appearance of your app. The server is where the logic of the app is implemented—for example, where calculations are performed and plots are generated.

An empty UI is created using the fluidPage() function. Adding text to a Shiny app is done by adding text inside fluidPage() as an argument. In fact, the entire UI is built by supplying the fluidPage() function with as many arguments as you want.

Instructions
100 XP
Create a Shiny app that displays the text "Shiny is fun" by following these specific instructions:

Load the shiny package.
Create the UI for the Shiny app using the fluidPage() function.
Add the text "Shiny is fun" to the UI.

```{r st}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # Add the text "Shiny is fun"
  "Shiny is fun"
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Formatted text
Shiny has many functions that can transform plain text into formatted text. Simply place text inside the h1() function to create a primary header (e.g. a title), h2() for a secondary header, strong() to make text bold, em() to make text italicized, or any of the other formatting functions.

You can also intermingle plain text and formatted text as much as you'd like—just remember to separate all the elements with commas!

Instructions
100 XP
Place the following text inside the Shiny app:

The word "DataCamp" as a primary header.
The words "Shiny use cases course" as a secondary header.
The word "Shiny" in italics.
The words "is fun" as bold text.
After completing the instructions, your Shiny app should render the following text:

DataCamp
Shiny use cases course
Shiny is fun

```{r ft}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # "DataCamp" as a primary header
  h1("DataCamp"),
  # "Shiny use cases course" as a secondary header
  h2("Shiny use cases course"),
  # "Shiny" in italics
  em("Shiny"),
  # "is fun" as bold text
  strong("is fun")
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Adding structure to your app
Layouts in Shiny are used to give your app some structure by placing elements in certain desired positions.

A sidebar layout, created with the sidebarLayout() function, provides a basic two-column structure with a smaller sidebar on the left and a larger main panel on the right.

The sidebar layout function takes two arguments: sidebarPanel() and mainPanel(). Each of these panels can contain any arbitrary mix of text/HTML elements, in a similar fashion to how you can mix these elements inside a fluidPage().

Instructions
100 XP
Your task is to add a sidebar layout to the existing app, such that the inputs will be on the left side and the outputs will be in the main panel. Specifically, you need to:

Define the UI for the Shiny application.
Add a sidebar layout to the page.
Add a sidebar panel to the layout, and place the inputs and text in it.
Add a main panel to the layout, and place the plot and table in it.

```{r astya}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # Add a sidebar layout to the application
  sidebarLayout(
    # Add a sidebar panel around the text and inputs
    sidebarPanel(
      h4("Plot parameters"),
      textInput("title", "Plot title", "Car speed vs distance to stop"),
      numericInput("num", "Number of cars to show", 30, 1, nrow(cars)),
      sliderInput("size", "Point size", 1, 5, 2, 0.5)
    ),
    # Add a main panel around the plot and table
    mainPanel(
      plotOutput("plot"),
      tableOutput("table")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    plot(cars[1:input$num, ], main = input$title, cex = input$size)
  })
  output$table <- renderTable({
    cars[1:input$num, ]
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Adding inputs
Inputs are Shiny's way of allowing users to interact with an app. For example, textInput() is used to let the user enter text and numericInput() lets the user select a number. In the next chapter we will see many other types of inputs.

To add an input to your app, simply add the input function inside fluidPage(). Recall from the video that all input functions have the same first two arguments: inputId and label.

Instructions
100 XP
Define the UI for the Shiny application.
Create a numeric input with ID "age" and a descriptive label of "How old are you?".
Create a text input with ID "name" and a label of "What is your name?".

```{r ai}
library(shiny)

# Define UI for the application
ui <- fluidPage(
  # Create a numeric input with ID "age" and label of
  # "How old are you?"
  numericInput("age", "How old are you?", value = 20),
  
  # Create a text input with ID "name" and label of 
  # "What is your name?"
  textInput("name", "What is your name?")
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Adding placeholders for outputs
Outputs are any object that should be displayed to the user and is generated in R, such as a plot or a table.

To add an output to a Shiny app, the first thing you need to do is add a placeholder for the output that tells Shiny where to place the output.

There are several output placeholder functions provided by Shiny, one for each type of output. For example, plotOutput() is for displaying plots, tableOutput() is for outputting tables, and textOutput() is for dynamic text.

Instructions
100 XP
Create a text input with an ID of "name" in the sidebar panel.
Add three output placeholders to the main panel:
A text output with ID "greeting" (line 14).
A plot output with ID "cars_plot" (line 16).
A table output with ID "iris_table" (line 18).

```{r apfo}
library(shiny)

# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      # Create a text input with an ID of "name"
      textInput("name", "What is your name?", "Dean"),
      numericInput("num", "Number of flowers to show data for",
                   10, 1, nrow(iris))
    ),
    mainPanel(
      # Add a placeholder for a text output with ID "greeting"
      textOutput(outputId = "greeting"),
      # Add a placeholder for a plot with ID "cars_plot"
      plotOutput("cars_plot"),
      # Add a placeholder for a table with ID "iris_table"
      tableOutput("iris_table")
    )
  )
)

# Define the server logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)
```

Constructing output objects
There are three rules to build an output in Shiny:

Build the object with the appropriate render*() function.

Save the result of the render function into the output list, which is a parameter of the server function. Specifically, save it into output$<outputId> in order to replace the output placeholder in the UI that has ID outputId.

If the output relies on any user-modified input values, you can access any of the inputs using the input parameter of the server function. Specifically, input$<inputId> will always return the current value of the input field that has ID inputId.

Instructions
100 XP
You are given a Shiny app with a fully functional UI portion. Your task is to construct all the outputs. Specifically:

Create a plot of the cars dataset in the plot output placeholder with ID "cars_plot" (line 23).
In the "greeting" text output, render a text greeting in the form of "Hello NAME", where NAME is the value of the name input (line 28).
In the "iris_table" output, show a table of the first n rows of the iris dataset, where n is the value of the numeric input (line 33).

```{r coo}
# Load the shiny package
library(shiny)

# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("name", "What is your name?", "Dean"),
      numericInput("num", "Number of rows to show in the table",
                   10, 1, nrow(iris))
    ),
    mainPanel(
      textOutput("greeting"),
      plotOutput("cars_plot"),
      tableOutput("iris_table")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  # Create a plot of the "cars" dataset 
  output$cars_plot <- renderPlot({
    plot(cars)
  })
  
  # Render a text greeting as "Hello <name>"
  output$greeting <- renderText({
    paste("Hello", input$name)
  })
  
  # Show a table of the first n rows of the "iris" data
  output$iris_table <- renderTable({
    data <- iris[1:input$num, ]
    data
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Reactive contexts
Reactive values are special constructs in Shiny; they are not seen anywhere else in R programming. As such, they cannot be used in just any R code, reactive values can only be accessed within a reactive context.

This is the reason why any variable that depends on a reactive value must be created using the reactive() function, otherwise you will get an error. The shiny server itself is not a reactive context, but the reactive() function, the observe() function, and all render*() functions are.

Instructions
100 XP
You are provided with a Shiny app containing two numeric inputs, num1 and num2, and a text output. Your task is to:

In a reactive variable called my_sum, calculate the sum of the two numeric inputs (line 10).
In a reactive variable called my_average, calculate the average of the two inputs (line 14).
In the text output, display the calculated average using the reactive variables (line 23).

```{r rc}
ui <- fluidPage(
  numericInput("num1", "Number 1", 5),
  numericInput("num2", "Number 2", 10),
  textOutput("result")
)

server <- function(input, output) {
  # Calculate the sum of the inputs
  my_sum <- reactive({
    input$num1 + input$num2
  })

  # Calculate the average of the inputs
  my_average <- reactive({
    my_sum() / 2
  })
  
  output$result <- renderText({
    paste(
      # Print the calculated sum
      "The sum is", my_sum(),
      # Print the calculated average
      "and the average is", my_average()
    )
  })
}

shinyApp(ui, server)
```

## Perfect Plot

More exploration of the Gapminder data
To use the gapminder data in a Shiny app, you will often have to filter the dataset in order to retain only a subset of the rows. You can use the subset() function for that.

Instructions
100 XP
You are given a Shiny app that contains an empty text output. Your task is to:

Load the gapminder package.
Determine the population of France in year 1972 using the subset() function, and display that number in the text output (line 14).

```{r megd}
# Load the gapminder package
library(gapminder)

# Define UI for the application
ui <- fluidPage(
  "The population of France in 1972 was", 
  textOutput("answer")
)

# Define the server function
server <- function(input, output) {
  output$answer <- renderText({
    # Determine the population of France in year 1972
    subset(gapminder, country == "France" & year == 1972)$pop
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Add a plot title: text input
In Shiny, as soon as the user changes the value of any input, Shiny makes the current value of that input immediately available to you in the server through the input argument of the server function. You can retrieve the value of any input using input$<inputId>.

In order to assign a default initial value to a text input, the value argument is used.

Instructions
100 XP
The given Shiny app plots the GDP per capita vs life expectancy of countries in the gapminder dataset. Your task is to add a text input that lets users change the title of the plot. Specifically:

Add a text input to the UI with ID "title", a label of "Title", and a default value of "GDP vs life exp".
In the server code, make the title of the plot always reflect the current value of the title input by placing the title inside the ggtitle() function (line 24).

```{r aptti}
# Load the ggplot2 package for plotting
library(ggplot2)

# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      # Add a title text input
      textInput("title", "Title", "GDP vs life exp")
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10() +
      # Use the input value as the plot's title
      ggtitle(input$title)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Change the point size: numeric input
Numeric inputs have a few more arguments that text inputs do not have, such as min and max, which define the minimum and maximum numbers that can be chosen.

Note that when the value of an input is accessed in the server code, Shiny is smart enough to know what type of input was used, and therefore what type of object it should return. This means that if you have a numeric input with ID "foo", then input$foo will return a numeric value.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to add a numeric input that the user can use to change the size of the points on the plot. Specifically:

Add a numeric input to the UI with ID "size", a label of "Point size", a default value of 1, and a minimum value of 1.
Add code to the server so that the numeric input will determine the point size in the plot (line 20).

```{r cpsni}
# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      # Add a size numeric input
      numericInput("size","Point size",1,min = 1)
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      # Use the size input as the plot point size
      geom_point(size = input$size) +
      scale_x_log10() +
      ggtitle(input$title)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Fit a smooth curve: checkbox input
Unlike text and numeric inputs, checkbox inputs are limited to only two possible values: TRUE or FALSE. When the user checks a checkbox input, the input has a value of TRUE, and if the box is unchecked then it returns FALSE.

Note that the value parameter of the checkboxInput() function, which defines the initial value, can only be set to either TRUE or FALSE.

The code for the Shiny app from the last exercise is provided with some modification. The ggplot plot object inside renderPlot() is now assigned to a variable p.

Instructions
100 XP
Your task is to add a checkbox input that, when checked, will add a line of best fit to the plot. Specifically:

Add a checkbox input to the UI with ID "fit", a label of "Add line of best fit", and an initial state of being unchecked.
Add code to the server so that when the input is checked, a line of best fit is added to the plot. The code for adding a line of best fit is provided (line 26).

```{r fscci}
# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      # Add a checkbox for line of best fit
      checkboxInput("fit","Add line of best fit",value = FALSE)
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    p <- ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size) +
      scale_x_log10() +
      ggtitle(input$title)
    
    # When the "fit" checkbox is checked, add a line
    # of best fit
    if (input$fit == TRUE) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Add colours to your plot: radio buttons
Radio buttons are used when you want to present the user with several options and ask them to choose one. They have a choices parameter that defines the different options the user can choose from, and a selected argument that defines which choice is selected initially. Note that there is no value parameter, though you can think of selected as having a similar role.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to add radio buttons that give the user a choice of color to use for the plot. Specifically:

Add radio buttons to the UI with ID "color", a label of "Point color", and four choices: "blue", "red", "green", "black".
Add code to the server such that the points in the plot will have the color that is selected in the radio buttons (line 22).

```{r actyprb}
# Define UI for the application
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      # Add radio buttons for colour
      radioButtons("color", "Point color", c("blue", "red", "green", "black"))
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    p <- ggplot(gapminder, aes(gdpPercap, lifeExp)) +
      # Use the value of the color input as the point colour
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Add a continent selector: select input
When there are many options to let the user choose from, radio buttons can take up a lot of space and may not be ideal. Select inputs—also called 'dropdown lists'—can also be used to ask the user to choose an option from a list of choices, but in a more compact way. With a select input, all the options appear in a scrollable list, so it can be used even if you have many choices.

Similar to radio buttons, select inputs also have choices and selected parameters. Additionally, select inputs have a multiple argument, which, when set to TRUE, allows the user to select more than one value.

The code for the Shiny app from the last exercise is provided with slight modifications.

Instructions
100 XP
Add a selectInput() to the UI with ID "continents" and a label of "Continents", with the default continent set to "Europe".
The choices in the list should be all the different continents that exist in the gapminder dataset.
Allow the user to select multiple continents simultaneously.
Add code to the server such that only data for the selected continent is shown, by subsetting the gapminder dataset (line 23).

```{r acssi}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      radioButtons("color", "Point color",
                   choices = c("blue", "red", "green", "black")),
      # Add a continent dropdown selector
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe")
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    # Subset the gapminder dataset by the chosen continents
    data <- subset(gapminder,
                   continent %in% input$continents)

    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Add a year filter: numeric slider input
Slider inputs can be used for similar purposes to numeric inputs, as they both provide the user with a way to select a number.

If the initial provided value (the value argument) of the slider is a single number, then the slider will be used to select single numbers. However, if the initial value is a vector of two numbers, then the slider will be used to select two numbers instead of just a single value.

We have already seen that different inputs may have different arguments. It can be difficult to remember the exact arguments each input uses. The only way to find out what arguments you can use with a specific input function is by looking at its documentation or help file.

Instructions
100 XP
Add a sliderInput() to the UI with ID "years" and a label of "Years" (line 14).
Set the minimum value to the earliest year in the dataset, and the maximum value to the latest year in the dataset.
By default, the endpoints of the slider should be set to 1977 and 2002, so that only data between these two years (inclusive) is shown.
Add code to the server such that the years that are chosen in the input are used to subset the gapminder data, and only records within these years will show up (line 28).

```{r ayfasi}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      radioButtons("color", "Point color",
                   choices = c("blue", "red", "green", "black")),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      # Add a slider selector for years to filter
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002), step = 1)
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    # Subset the gapminder data by the chosen years
    data <- subset(gapminder,
                   continent %in% input$continents &
                   year >= input$years[1] & year <= input$years[2])
    
    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Add colours to your plot: color input
The colourpicker package provides a color input, available through the colourInput() function. Even though color inputs are not part of the shiny package, they behave in the same way as any other input.

A color input can have many different arguments you can explore, but we will only use the basic arguments: inputId, label, and value. The value argument accepts a color to use as the initial value. Colours can be specified in several different formats, but the easiest one is to simply use English color names such as "red" or "yellow".

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to replace the radio buttons that are used to select a color with a color input. Specifically:

Load the colourpicker package.
Find the UI function that creates the radio buttons that are used for selecting a colour, and replace it with a color input (line 12).
The color input should have ID "color", a label of "Point color", and a default color of "blue".

```{r actypci}
# Load the colourpicker package
library(colourpicker)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),

      # Replace the radio buttons with a color input
      colourInput("color", "Point color", value = "blue", showColour = c("both", "text", "background")),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002))
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    data <- subset(gapminder,
                   continent %in% input$continents &
                   year >= input$years[1] & year <= input$years[2])
    
    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Making your plot larger
Just as input functions can have different arguments depending on the type of input, so can output placeholder functions have different arguments to modify their appearance or behaviour.

For example, when displaying a plot in a Shiny app using plotOutput(), the height of the plot by default will be 400 pixels. The plotOutput() function has some parameters that can be used to modify the height or width of a plot.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to make the plot larger. Specifically:

600 pixels tall and 600 pixels wide. You can consult the plotOutput() documentation to find out what parameters to use (line 18).

```{r mypl}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      colourInput("color", "Point color", value = "blue"),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002))
    ),
    mainPanel(
      # Make the plot 600 pixels wide and 600 pixels tall
      plotOutput("plot", width = "600px", height = "600px")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  output$plot <- renderPlot({
    data <- subset(gapminder,
                   continent %in% input$continents &
                     year >= input$years[1] & year <= input$years[2])
    
    p <- ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point(size = input$size, col = input$color) +
      scale_x_log10() +
      ggtitle(input$title)
    
    if (input$fit) {
      p <- p + geom_smooth(method = "lm")
    }
    p
  })
}

shinyApp(ui = ui, server = server)
```

Make your plot interactive
plotly is a popular package for creating interactive plots in Shiny. There are several other packages for interactive visualizations, but we will use plotly largely because of its function ggplotly(), which converts a ggplot2 plot into an interactive one.

Instructions
100 XP
The code for the Shiny app from the last exercise is provided. Your task is to replace the ggplot2 plot with a plotly plot. Specifically:

Load the plotly package.
Replace the plot output function with plotlyOutput (line 20).
Replace the plot render function with renderPlotly (line 29).
Convert the existing ggplot2 plot to a plotly plot (line 31).

```{r mypi}
# Load the plotly package
library(plotly)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textInput("title", "Title", "GDP vs life exp"),
      numericInput("size", "Point size", 1, 1),
      checkboxInput("fit", "Add line of best fit", FALSE),
      colourInput("color", "Point color", value = "blue"),
      selectInput("continents", "Continents",
                  choices = levels(gapminder$continent),
                  multiple = TRUE,
                  selected = "Europe"),
      sliderInput("years", "Years",
                  min(gapminder$year), max(gapminder$year),
                  value = c(1977, 2002))
    ),
    mainPanel(
      # Replace the `plotOutput()` with the plotly version
      plotlyOutput("plot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  # Replace the `renderPlot()` with the plotly version
  output$plot <- renderPlotly({
    # Convert the existing ggplot2 to a plotly plot
    ggplotly({
      data <- subset(gapminder,
                     continent %in% input$continents &
                       year >= input$years[1] & year <= input$years[2])
      
      p <- ggplot(data, aes(gdpPercap, lifeExp)) +
        geom_point(size = input$size, col = input$color) +
        scale_x_log10() +
        ggtitle(input$title)
      
      if (input$fit) {
        p <- p + geom_smooth(method = "lm")
      }
      p
    })
  })
}

shinyApp(ui = ui, server = server)
```

See the data in a table
An easy first step in exploring a dataset is to simply view it as a table.

So far we have focused mostly on inputs—interactive widgets that allow the user to select values. Now we want to have a table in our app, and send data to display in the table. To display objects in Shiny, we need to use output and render functions.

Instructions
100 XP
Given a minimal Shiny app, add a table that will show the gapminder dataset. Specifically:

Add a placeholder for the table by creating a table output with ID "table" in the UI.
Use the corresponding render function in the server code to render the table.

```{r sdt}
ui <- fluidPage(
  h1("Gapminder"),
  # Add a placeholder for a table output
  tableOutput("table")
)

server <- function(input, output) {
  # Call the appropriate render function 
  output$table <- renderTable({
    # Show the gapminder object in the table
    gapminder
  })
}

shinyApp(ui, server)
```

Filter by life expectancy
The real benefit of using Shiny comes when inputs are combined with outputs. The table created in the last exercise is static—it cannot be changed—but for exploration, it would be better if the user could decide what subset of the data to see.

This can be achieved by adding an input that lets the user select a value to filter the data. This way, the table we created in the previous exercise can be made dynamic.

One of the variables in the gapminder dataset is lifeExp (life expectancy). Your task is to add a slider input to the Shiny app that lets the user choose a minimum and maximum life expectancy, and the table will only show data that matches these values.

Instructions
100 XP
Add a slider input to the UI with ID "life", a minimum value of 0, maximum value of 120, and default selection of 30-50.
Inside the render function, use the input value to subset the gapminder data to only include records with a lifeExp that is between the minimum and maximum values (both inclusive).

```{r fle}
ui <- fluidPage(
  h1("Gapminder"),
  # Add a slider for life expectancy filter
  sliderInput(inputId = "life", label = "Life expectancy",
      min = 0, max = 120,
      value = c(30, 50)),
  tableOutput("table")
)

server <- function(input, output) {
  output$table <- renderTable({
    data <- gapminder
    data <- subset(
      data,
      # Use the life expectancy input to filter the data
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    data
  })
}

shinyApp(ui, server)
```

Select a continent to view
When exploring a dataset, it is often useful to experiment with filtering more than one variable. For example, you might be interested in only seeing data for African countries that had a specific life expectancy.

Instructions
100 XP
Add a select input that allows the user to select a specific continent to view. Specifically:

Add a select input to the UI with ID "continent" and a label of "Continent".
Inside the render function, use the continent input value to only select data from the chosen continent (line 21).

```{r scv}
ui <- fluidPage(
  h1("Gapminder"),
  sliderInput(inputId = "life", label = "Life expectancy",
              min = 0, max = 120,
              value = c(30, 50)),
  # Add a continent selector dropdown
  selectInput("continent", "Continent", choices = levels(gapminder$continent)),
  tableOutput("table")
)

server <- function(input, output) {
  output$table <- renderTable({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    data <- subset(
      data,
      # Filter the data according to the continent input value
      continent == input$continent
    )
    data
  })
}

shinyApp(ui, server)
```

Allow "All" continents to be viewed
Before adding the continent selector, the Shiny app showed data for all continents. Now that the continent selector was added, the data can be viewed per continent. But what if the user decides they actually don't want to filter for a specific continent, and they prefer to see all of them? Unfortunately, adding the continent selector removed that ability.

The choices argument of the selectInput() function can be modified to add another value to the continent list, and when this value is chosen, continent filtering can be turned off.

Instructions
100 XP
Add an option in the select input to select "All" continents. When that option is selected, do not perform any continent filtering. Specifically:

Add an "All" value to the list of options that are provided to the select input in the UI.
In the server, use an if statement to check if the continent is set to "All". If "All" is chosen, then do not perform any filtering on continents (line 20).

```{r aacv}
ui <- fluidPage(
  h1("Gapminder"),
  sliderInput(inputId = "life", label = "Life expectancy",
              min = 0, max = 120,
              value = c(30, 50)),
  # Add an "All" value to the continent list
  selectInput("continent", "Continent",
              choices = c("All", levels(gapminder$continent))),
  tableOutput("table")
)

server <- function(input, output) {
  output$table <- renderTable({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    # Don't subset the data if "All" continent are chosen
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })
}

shinyApp(ui, server)
```

Plot the data
Recall that plots are output objects, and as such they are added to a Shiny app using the plotOutput() + renderPlot() functions. The output function is added to the UI to determine where to place the plot, and the render function in the server code is responsible for generating the plot.

Your task is to add a plot of GDP per capita vs life expectancy to the app. The data used in the plot should be the same data that is shown in the table; that is, the data in the plot should only show records that match the input filters.

Instructions
100 XP
Add a placeholder for a plot output to the UI with an ID of "plot".
In the server, use the appropriate render function to create the plot (line 30).
Re-use the same data-filtering code that the output table uses for the plot data (line 32).

```{r ptd}
ui <- fluidPage(
  h1("Gapminder"),
  sliderInput(inputId = "life", label = "Life expectancy",
              min = 0, max = 120,
              value = c(30, 50)),
  selectInput("continent", "Continent",
              choices = c("All", levels(gapminder$continent))),
  # Add a plot output
  plotOutput("plot"),
  tableOutput("table")
)

server <- function(input, output) {
  output$table <- renderTable({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })

  # Create the plot render function  
  output$plot <- renderPlot({
    # Use the same filtered data that the table uses
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10()
  })
}

shinyApp(ui, server)
```

Download the filtered data
Downloading files is achieved using the pair of functions downloadButton() and downloadHandler(). These two functions pair together similarly to how output and render functions are paired: downloadButton() determines where in the UI it will show up, while downloadHandler() needs to be saved into the output list and has the actual R code to create the downloaded file.

Instructions
100 XP
Add the ability to download the data that is currently viewed in the table as a CSV file. Specifically:

Add a download button to the UI with ID "download_data" and a label of "Download".
Add a download handler to the server (line 31).
Give the downloaded file a name of "gapminder_data.csv" (line 33).
Write the filtered data into a CSV file (line 50).

```{r dfd}
ui <- fluidPage(
  h1("Gapminder"),
  sliderInput(inputId = "life", label = "Life expectancy",
              min = 0, max = 120,
              value = c(30, 50)),
  selectInput("continent", "Continent",
              choices = c("All", levels(gapminder$continent))),
  # Add a download button
  downloadButton(outputId = "download_data", label = "Download"),
  plotOutput("plot"),
  tableOutput("table")
)

server <- function(input, output) {
  output$table <- renderTable({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })

  # Create a download handler
  output$download_data <- downloadHandler(
    # The downloaded file is named "gapminder_data.csv"
    filename = "gapminder_data.csv",
    content = function(file) {
      # The code for filtering the data is copied from the
      # renderTable() function
      data <- gapminder
      data <- subset(
        data,
        lifeExp >= input$life[1] & lifeExp <= input$life[2]
      )
      if (input$continent != "All") {
        data <- subset(
          data,
          continent == input$continent
        )
      }
      
      # Write the filtered data into a CSV file
      write.csv(data, file, row.names = FALSE)
    }
  )

  output$plot <- renderPlot({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10()
  })
}

shinyApp(ui, server)
```

Reactive variables reduce code duplication
In the previous exercises, the code to filter gapminder according to the input values is duplicated three times: once in the table, once in the plot, and once in the download handler.

Reactive variables can be used to reduce code duplication, which is generally a good idea because it makes maintenance easier.

Instructions
100 XP
The duplicated code chunks that filter the data have been removed. Your task is to add a reactive variable that filters the data, and use this variable instead. Specifically:

Create a reactive variable named filtered_data by using the reactive() function that uses the filtering code from the previous exercise (line 15).
Use the reactive variable to render the table output, the plot output, and the download file (lines 33, 42, and 50).

```{r rvrcd}
ui <- fluidPage(
  h1("Gapminder"),
  sliderInput(inputId = "life", label = "Life expectancy",
              min = 0, max = 120,
              value = c(30, 50)),
  selectInput("continent", "Continent",
              choices = c("All", levels(gapminder$continent))),
  downloadButton(outputId = "download_data", label = "Download"),
  plotOutput("plot"),
  tableOutput("table")
)

server <- function(input, output) {
  # Create a reactive variable named "filtered_data"
  filtered_data <- reactive({
    # Filter the data (copied from previous exercise)
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })
  
  output$table <- renderTable({
    # Use the filtered_data variable to render the table output
    data <- filtered_data()
    data
  })

  output$download_data <- downloadHandler(
    filename = "gapminder_data.csv",
    content = function(file) {
      # Use the filtered_data variable to create the data for
      # the downloaded file
      data <- filtered_data()
      write.csv(data, file, row.names = FALSE)
    }
  )

  output$plot <- renderPlot({
    # Use the filtered_data variable to create the data for
    # the plot
    data <- filtered_data()
    ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10()
  })
}

shinyApp(ui, server)
```

Make the table interactive
Datatables from the DT package are often a better way to display data in a Shiny app when compared to the built-in tables. Shiny tables can be converted to datatables with two simple code modifications: instead of using tableOutput() and renderTable(), you use DT::dataTableOutput() and DT::renderDataTable(). Datatables have a wide variety of customization options, but we will not be using any special options.

Note that with the DT package, the convention is to not load the DT package, and instead use the DT:: prefix when calling the datatable functions.

Instructions
100 XP
The code for the Shiny app from the last coding exercise is provided without any modifications. Your task is to replace the basic Shiny table with a DT table. Specifically:

In the UI, replace the table output function with the DT datatable output (line 11).
In the server, replace the table rendering function with a DT datatable render funtion (line 31).

```{r mti}
ui <- fluidPage(
  h1("Gapminder"),
  sliderInput(inputId = "life", label = "Life expectancy",
              min = 0, max = 120,
              value = c(30, 50)),
  selectInput("continent", "Continent",
              choices = c("All", levels(gapminder$continent))),
  downloadButton("download_data"),
  plotOutput("plot"),
  # Replace the tableOutput() with DT's version
  DT::dataTableOutput("table")
)

server <- function(input, output) {
  filtered_data <- reactive({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })
  
  # Replace the renderTable() with DT's version
  output$table <- DT::renderDataTable({
    data <- filtered_data()
    data
  })

  output$download_data <- downloadHandler(
    filename = "gapminder_data.csv",
    content = function(file) {
      data <- filtered_data()
      write.csv(data, file, row.names = FALSE)
    }
  )

  output$plot <- renderPlot({
    data <- filtered_data()
    ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10()
  })
}

shinyApp(ui, server)
```

Place different outputs on different tabs
Tabs are useful when you have too much content and want to split it up. To create a tab, you simply wrap UI elements in the tabPanel() function, and you need to supply a title for the tab using the title argument.

In order for tabs to appear in the UI, the tab panels need to be grouped into a tabset "container", by wrapping all the tab panels inside tabsetPanel().

Your task is to add tabs to the Shiny app, such that the inputs and download button are in one tab, the plot is in another tab, and the table is in a third tab. Since this is purely a visual change, all the code changes are to be done in the UI portion only.

Instructions
100 XP
Use the tabsetPanel() function to create a container for three tab panels:
A first tab for the inputs, and name the tab "Inputs".
A second tab that shows the plot, and name the tab "Plot" (line 16).
A third tab that shows the table, and name the tab "Table" (line 21).

```{r pdodt}
ui <- fluidPage(
    h1("Gapminder"),
    # Create a container for tab panels
    tabsetPanel(
        # Create an "Inputs" tab
        tabPanel(
            title = "Inputs",
            sliderInput(inputId = "life", label = "Life expectancy",
                        min = 0, max = 120,
                        value = c(30, 50)),
            selectInput("continent", "Continent",
                        choices = c("All", levels(gapminder$continent))),
            downloadButton("download_data")
        ),
        # Create a "Plot" tab
        tabPanel(
            title = "Plot",
            plotOutput("plot")
        ),
        # Create "Table" tab
        tabPanel(
            title = "Table",
            DT::dataTableOutput("table")
        )
    )
)

server <- function(input, output) {
  filtered_data <- reactive({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })
  
  output$table <- DT::renderDataTable({
    data <- filtered_data()
    data
  })

  output$download_data <- downloadHandler(
    filename = "gapminder_data.csv",
    content = function(file) {
      data <- filtered_data()
      write.csv(data, file, row.names = FALSE)
    }
  )

  output$plot <- renderPlot({
    data <- filtered_data()
    ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10()
  })
}

shinyApp(ui, server)
```

Add CSS to modify the look of the app
CSS is an extremely popular markup language that is used to tell the browser how to display elements on a page. You need to use CSS if you want to deviate from the default look-and-feel of Shiny and want to customize the appearance of different items in your app.

Recall that CSS is comprised of a set of rules, where each rule is a property: value pair associated with an element on the page. It's possible to include CSS in your app by writing it in a separate file and importing it with includeCSS(), but in this course we will use the simpler approach of placing the CSS code inside tags$style() in the UI.

Instructions
100 XP
Write CSS rules to modify the app in the following ways:
Change the background color of the download button to orange (line 5).
Change the text size of the download button to 20 pixels (line 8).
Change the text color of the table to red (line 13).
Add these CSS rules to the Shiny app (line 20).

```{r addCSS}
my_css <- "
#download_data {
  /* Change the background color of the download button
     to orange. */
  background: orange;

  /* Change the text size to 20 pixels. */
  font-size: 20px;
}

#table {
  /* Change the text color of the table to red. */
  color: red;
}
"

ui <- fluidPage(
  h1("Gapminder"),
  # Add the CSS that we wrote to the Shiny app
  tags$style(my_css),
  tabsetPanel(
    tabPanel(
      title = "Inputs",
      sliderInput(inputId = "life", label = "Life expectancy",
                  min = 0, max = 120,
                  value = c(30, 50)),
      selectInput("continent", "Continent",
                  choices = c("All", levels(gapminder$continent))),
      downloadButton("download_data")
    ),
    tabPanel(
      title = "Plot",
      plotOutput("plot")
    ),
    tabPanel(
      title = "Table",
      DT::dataTableOutput("table")
    )
  )
)

server <- function(input, output) {
  filtered_data <- reactive({
    data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
    )
    if (input$continent != "All") {
      data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })
  
  output$table <- DT::renderDataTable({
    data <- filtered_data()
    data
  })

  output$download_data <- downloadHandler(
    filename = "gapminder_data.csv",
    content = function(file) {
      data <- filtered_data()
      write.csv(data, file, row.names = FALSE)
    }
  )

  output$plot <- renderPlot({
    data <- filtered_data()
    ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10()
  })
}

shinyApp(ui, server)
```

